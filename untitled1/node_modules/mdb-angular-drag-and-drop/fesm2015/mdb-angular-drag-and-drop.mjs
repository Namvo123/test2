import * as i0 from '@angular/core';
import { InjectionToken, EventEmitter, Directive, Optional, SkipSelf, Inject, Input, HostBinding, Output, ContentChildren, NgModule } from '@angular/core';
import { Subject, merge, fromEvent } from 'rxjs';
import { filter, switchMap, tap, takeUntil, first } from 'rxjs/operators';

function moveItemToNewContainer(previousContainer, newContainer, previousIndex, newIndex) {
    if (previousContainer.length > 0) {
        const item = previousContainer.splice(previousIndex, 1)[0];
        newContainer.splice(newIndex, 0, item);
    }
}
function copyItemToNewContainer(previousContainer, newContainer, previousIndex, newIndex) {
    if (previousContainer.length > 0) {
        const item = previousContainer[previousIndex];
        newContainer.splice(newIndex, 0, item);
    }
}
function moveItemsInContainer(container, previousIndex, newIndex) {
    const item = container[previousIndex];
    container.splice(previousIndex, 1);
    container.splice(newIndex, 0, item);
}
function getElementRect(element) {
    const elementRect = element.getBoundingClientRect();
    return {
        top: elementRect.top,
        right: elementRect.right,
        bottom: elementRect.bottom,
        left: elementRect.left,
        width: elementRect.width,
        height: elementRect.height,
    };
}
function cloneNode(node) {
    const clone = node.cloneNode(true);
    clone.removeAttribute('id');
    return clone;
}
function destroyNode(node) {
    if (node && node.parentNode) {
        node.parentNode.removeChild(node);
    }
}

const MDB_DRAGGABLE_PARENT = new InjectionToken('MDB_DRAGGABLE_PARENT');
class MdbDraggableDirective {
    constructor(_elementRef, _ngZone, _draggableParent) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._draggableParent = _draggableParent;
        this.copy = false;
        this.disabled = false;
        this.lockAxis = null;
        this.autoScroll = false;
        this.scrollSpeed = 25;
        this.scrollSensitivity = 30;
        this.delay = 0;
        this.threshold = 0;
        this.dragStart = new EventEmitter();
        this.dragEnd = new EventEmitter();
        this._hostPosition = { x: 0, y: 0 };
        this._startPosition = { x: 0, y: 0 };
        this._startTransform = { x: 0, y: 0 };
        this._isDragging = false;
        this._isMoving = false;
        this._boundaries = null;
        this._destroy$ = new Subject();
        this._sortableContainer = null;
        this._originalContainer = null;
    }
    get boundaryElement() {
        return this._boundaryElement;
    }
    set boundaryElement(value) {
        if (typeof value === 'string') {
            this._boundaryElement = this._getHtmlElement(value);
        }
        else {
            this._boundaryElement = value;
        }
    }
    get handle() {
        return this._handle;
    }
    set handle(value) {
        if (typeof value === 'string') {
            this._handle = this._getHtmlElement(value);
        }
        else {
            this._handle = value;
        }
    }
    // @HostBinding('class.draggable') draggable = true;
    get isMoving() {
        return this._isMoving;
    }
    ngOnInit() {
        const target = this.handle ? this.handle : this._elementRef.nativeElement;
        this._setupEvents(target);
        this._subscribeToEvents();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    _setupEvents(element) {
        this._pointerDown$ = merge(fromEvent(element, 'mousedown', { passive: false }), fromEvent(element, 'touchstart', { passive: false }));
        this._pointerMove$ = merge(fromEvent(document, 'mousemove', { passive: false }), fromEvent(document, 'touchmove', { passive: false }));
        this._pointerUp$ = merge(fromEvent(document, 'mouseup', { passive: false }), fromEvent(document, 'touchend', { passive: false }));
    }
    _getHost() {
        return this._elementRef.nativeElement;
    }
    _getPlaceholder() {
        return this._placeholder;
    }
    _subscribeToEvents() {
        this._ngZone.runOutsideAngular(() => {
            const drag$ = this._pointerDown$.pipe(filter((startEvent) => startEvent.button !== 2 && !this.disabled), switchMap((event) => {
                this._handleDragStart(event);
                return this._pointerMove$.pipe(tap((moveEvent) => {
                    this._handleDragMove(moveEvent);
                }), takeUntil(this._pointerUp$));
            }), takeUntil(this._destroy$));
            const drop$ = this._pointerDown$.pipe(switchMap(() => {
                return this._pointerUp$.pipe(first(), tap(() => {
                    this._handleDragEnd();
                }));
            }), takeUntil(this._destroy$));
            drag$.subscribe();
            drop$.subscribe();
        });
    }
    _handleDragStart(event) {
        if (this._isDragging || this._isMoving) {
            return;
        }
        if (this._draggableParent) {
            event.stopPropagation();
        }
        this._isDragging = true;
        this._draggingStartTime = Date.now();
        const hostRect = this._elementRef.nativeElement.getBoundingClientRect();
        this._pickUpPosition = this._getPosition(event);
        this._startPosition.x = this._pickUpPosition.x - hostRect.left;
        this._startPosition.y = this._pickUpPosition.y - hostRect.top;
        if (this._boundaryElement) {
            this._measureBoundaries();
        }
        if (this._sortableContainer) {
            this._sortableContainer._onDragStart();
            this._originalContainer = this._sortableContainer;
            this._originalContainerRect = this._originalContainer.element.getBoundingClientRect();
            this._startIndex = this._sortableContainer._getDraggableIndex(this);
        }
    }
    _getHtmlElement(selector) {
        return document.querySelector(selector);
    }
    _measureBoundaries() {
        const viewRect = this._boundaryElement.getBoundingClientRect();
        const hostRect = this._elementRef.nativeElement.getBoundingClientRect();
        this._boundaries = {
            minX: viewRect.left - hostRect.left + this._hostPosition.x,
            maxX: viewRect.right - hostRect.right + this._hostPosition.x,
            minY: viewRect.top - hostRect.top + this._hostPosition.y,
            maxY: viewRect.bottom - hostRect.bottom + this._hostPosition.y,
        };
    }
    _handleDragMove(event) {
        const currentPosition = this._getPosition(event);
        const distanceX = Math.abs(currentPosition.x - this._pickUpPosition.x);
        const distanceY = Math.abs(currentPosition.y - this._pickUpPosition.y);
        if (!this._isMoving) {
            const isOverThreshold = distanceX + distanceY >= this.threshold;
            if (this._pickUpPosition && isOverThreshold) {
                const isAfterDelay = Date.now() - this._draggingStartTime >= this.delay;
                if (!isAfterDelay) {
                    return;
                }
                event.preventDefault();
                this._ngZone.run(() => {
                    this._isMoving = true;
                });
                if (this._sortableContainer) {
                    this._ngZone.run(() => {
                        this._initSortableElements();
                    });
                }
            }
            return;
        }
        event.preventDefault();
        this._hostPosition.x = currentPosition.x - this._pickUpPosition.x + this._startTransform.x;
        this._hostPosition.y = currentPosition.y - this._pickUpPosition.y + this._startTransform.y;
        if (this._boundaries) {
            this._applyBoundaries(this._boundaries);
        }
        if (this.lockAxis === 'x') {
            this._hostPosition.x = 0;
        }
        if (this.lockAxis === 'y') {
            this._hostPosition.y = 0;
        }
        if (this.autoScroll && !this._sortableContainer) {
            this._updateScrollPosition();
        }
        if (this._sortableContainer) {
            const originalContainer = this._originalContainer;
            const currentContainer = this._sortableContainer;
            const { x, y } = currentPosition;
            let newContainer = originalContainer._getContainerFromCoordinates(this, x, y);
            const isPointerOverOriginalContainer = !newContainer &&
                this._sortableContainer !== originalContainer &&
                originalContainer._isPointerOverItem(this._originalContainerRect, x, y);
            if (isPointerOverOriginalContainer) {
                newContainer = originalContainer;
            }
            if (newContainer && newContainer !== this._sortableContainer) {
                currentContainer._handleItemLeave(this);
                newContainer._handleItemEnter(this, currentPosition.x, currentPosition.y);
                this._sortableContainer = newContainer;
            }
            if (!this.copy) {
                originalContainer._initSortingEvents(this);
            }
            this._updatePosition(this._helper, currentPosition.x - this._startPosition.x, currentPosition.y - this._startPosition.y);
        }
        else {
            this._updatePosition(this._elementRef.nativeElement, this._hostPosition.x, this._hostPosition.y);
        }
    }
    _initSortableElements() {
        const tempElement = this._createTempElement();
        const host = this._elementRef.nativeElement;
        const hostParent = this._elementRef.nativeElement.parentNode;
        hostParent.insertBefore(tempElement, host);
        const placeholder = (this._placeholder = this._createPlaceholder());
        const helper = (this._helper = this._createHelper());
        this._elementRef.nativeElement.style.display = 'none';
        document.body.appendChild(hostParent.replaceChild(placeholder, host));
        document.body.appendChild(helper);
    }
    _createTempElement() {
        const tempElement = (this._tempElement = this._tempElement || document.createElement('div'));
        tempElement.style.display = 'none';
        return tempElement;
    }
    _getPosition(event) {
        const point = this._isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
        const scrollPosition = this._getDocumentScrollPosition();
        return {
            x: point.pageX - scrollPosition.left,
            y: point.pageY - scrollPosition.top,
        };
    }
    _isTouchEvent(event) {
        return event.type.startsWith('touch');
    }
    _getDocumentScrollPosition() {
        const documentElement = document.documentElement;
        const body = document.body;
        const top = documentElement.scrollTop || body.scrollTop;
        const left = documentElement.scrollLeft || body.scrollLeft;
        return { top, left };
    }
    _applyBoundaries(boundaries) {
        this._hostPosition.x = Math.max(boundaries.minX, this._hostPosition.x);
        this._hostPosition.x = Math.min(boundaries.maxX, this._hostPosition.x);
        this._hostPosition.y = Math.max(boundaries.minY, this._hostPosition.y);
        this._hostPosition.y = Math.min(boundaries.maxY, this._hostPosition.y);
    }
    _updateScrollPosition() {
        const hostRect = this._elementRef.nativeElement.getBoundingClientRect();
        const height = document.documentElement.clientHeight;
        const width = document.documentElement.clientWidth;
        if (hostRect.top < this.scrollSensitivity) {
            document.documentElement.scrollTop -= this.scrollSpeed;
        }
        if (hostRect.top + hostRect.height > height - this.scrollSensitivity) {
            document.documentElement.scrollTop += this.scrollSpeed;
        }
        if (hostRect.left < this.scrollSensitivity) {
            document.documentElement.scrollLeft -= this.scrollSpeed;
        }
        if (hostRect.left + hostRect.width > width - this.scrollSensitivity) {
            document.documentElement.scrollLeft += this.scrollSpeed;
        }
    }
    _updatePosition(element, x, y) {
        const position = this._getTransform(x, y);
        element.style.transform = position;
    }
    _getTransform(x, y) {
        return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
    }
    _handleDragEnd() {
        if (!this._isMoving) {
            return;
        }
        if (this._sortableContainer) {
            const placeholderRect = this._placeholder.getBoundingClientRect();
            this._helper.classList.add('draggable-animating');
            this._updatePosition(this._helper, placeholderRect.left, placeholderRect.top);
            setTimeout(() => {
                this._elementRef.nativeElement.style.display = '';
                this._tempElement.parentNode.replaceChild(this._elementRef.nativeElement, this._tempElement);
                this._destroyHelper();
                this._destroyPlaceholder();
                this._ngZone.run(() => {
                    const previousIndex = this._startIndex;
                    const newIndex = this._sortableContainer._getDraggableIndex(this);
                    const previousContainer = this._originalContainer;
                    const newContainer = this._sortableContainer;
                    this._sortableContainer._onDragEnd();
                    this._originalContainer._onDragEnd();
                    this._originalContainer._emitDropEvent(this, previousContainer, newContainer, previousIndex, newIndex);
                    this._sortableContainer = this._originalContainer;
                });
            }, 351);
        }
        else {
            this._startTransform.x = this._hostPosition.x;
            this._startTransform.y = this._hostPosition.y;
        }
        this._ngZone.run(() => {
            this._isMoving = false;
            this._isDragging = false;
        });
    }
    _destroyHelper() {
        if (this._helper) {
            destroyNode(this._helper);
        }
        this._helper = null;
    }
    _destroyPlaceholder() {
        if (this._placeholder) {
            destroyNode(this._placeholder);
        }
        this._placeholder = null;
    }
    _createPlaceholder() {
        const placeholder = cloneNode(this._elementRef.nativeElement);
        placeholder.style.visibility = 'hidden';
        placeholder.classList.add('draggable-placeholder');
        return placeholder;
    }
    _createHelper() {
        const helper = cloneNode(this._elementRef.nativeElement);
        const hostRect = this._elementRef.nativeElement.getBoundingClientRect();
        if (this.copy) {
            helper.style.opacity = '0.5';
        }
        helper.style.pointerEvents = 'none';
        helper.style.position = 'fixed';
        helper.style.top = '0';
        helper.style.left = '0';
        helper.style.margin = '0';
        helper.style.width = `${hostRect.width}px`;
        helper.style.height = `${hostRect.height}px`;
        helper.style.transform = this._getTransform(hostRect.left, hostRect.top);
        helper.classList.add('draggable-helper');
        return helper;
    }
}
MdbDraggableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.3", ngImport: i0, type: MdbDraggableDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: MDB_DRAGGABLE_PARENT, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
MdbDraggableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.2.3", type: MdbDraggableDirective, selector: "[mdbDraggable]", inputs: { copy: "copy", data: "data", disabled: "disabled", boundaryElement: "boundaryElement", handle: "handle", lockAxis: "lockAxis", autoScroll: "autoScroll", scrollSpeed: "scrollSpeed", scrollSensitivity: "scrollSensitivity", delay: "delay", threshold: "threshold" }, outputs: { dragStart: "dragStart", dragEnd: "dragEnd" }, host: { properties: { "class.draggable-disabled": "this.disabled", "class.draggable-dragging": "this.isMoving" } }, providers: [{ provide: MDB_DRAGGABLE_PARENT, useExisting: MdbDraggableDirective }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.3", ngImport: i0, type: MdbDraggableDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[mdbDraggable]',
                    providers: [{ provide: MDB_DRAGGABLE_PARENT, useExisting: MdbDraggableDirective }],
                }]
        }], ctorParameters: function () {
        return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: MdbDraggableDirective, decorators: [{
                        type: Optional
                    }, {
                        type: SkipSelf
                    }, {
                        type: Inject,
                        args: [MDB_DRAGGABLE_PARENT]
                    }] }];
    }, propDecorators: { copy: [{
                type: Input
            }], data: [{
                type: Input
            }], disabled: [{
                type: HostBinding,
                args: ['class.draggable-disabled']
            }, {
                type: Input
            }], boundaryElement: [{
                type: Input
            }], handle: [{
                type: Input
            }], lockAxis: [{
                type: Input
            }], autoScroll: [{
                type: Input
            }], scrollSpeed: [{
                type: Input
            }], scrollSensitivity: [{
                type: Input
            }], delay: [{
                type: Input
            }], threshold: [{
                type: Input
            }], dragStart: [{
                type: Output
            }], dragEnd: [{
                type: Output
            }], isMoving: [{
                type: HostBinding,
                args: ['class.draggable-dragging']
            }] } });

const MDB_SORTABLE_CONTAINER = new InjectionToken('MdbSortableContainer');
class MdbSortableContainerDirective {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this.autoScroll = false;
        this._containers = [];
        this.enterPredicate = () => true;
        this.sortingDisabled = false;
        this.itemDrop = new EventEmitter();
        this._inactiveItems = [];
        this._cachedDraggables = [];
        this._eventsInitialized = false;
        this._mouseEnterHandler = this._handleMouseEnter.bind(this);
        MdbSortableContainerDirective._sortableContainers.push(this);
    }
    get containers() {
        return this._containers;
    }
    set containers(containersArray) {
        this._containers = containersArray.map((container) => {
            if (typeof container === 'string') {
                return MdbSortableContainerDirective._sortableContainers.find((sortableContainer) => sortableContainer.id === container);
            }
            return container;
        });
    }
    get element() {
        return this._elementRef.nativeElement;
    }
    ngAfterContentInit() {
        this.draggables.forEach((draggable) => (draggable._sortableContainer = this));
        this._draggables = Array.from(this.draggables);
        this.draggables.changes.subscribe(() => {
            this.draggables.forEach((draggable) => (draggable._sortableContainer = this));
            this._draggables = Array.from(this.draggables);
        });
    }
    _onDragStart() {
        this.draggables.forEach((draggable) => (draggable._sortableContainer = this));
        this._draggables = Array.from(this.draggables);
        this._cacheDraggables();
    }
    _onDragEnd() {
        this._removeSortingEvents();
        this._eventsInitialized = false;
    }
    _emitDropEvent(item, previousContainer, newContainer, previousIndex, newIndex) {
        this.itemDrop.emit({
            item: item,
            previousContainer: previousContainer,
            newContainer: newContainer,
            previousIndex: previousIndex,
            newIndex: newIndex,
        });
    }
    _cacheDraggables() {
        this._cachedDraggables = this._draggables.map((draggable, index) => {
            const element = draggable._getHost();
            return {
                element: element,
                instance: draggable,
                offsetLeft: element.offsetLeft,
                offsetTop: element.offsetTop,
                translateX: 0,
                translateY: 0,
                index: index,
                rect: getElementRect(element),
            };
        });
    }
    _isPointerOverItem(rect, x, y) {
        const { top, bottom, left, right } = rect;
        const offset = 1;
        return (y + offset >= Math.floor(top) &&
            y - offset <= Math.floor(bottom) &&
            x + offset >= Math.floor(left) &&
            x - offset <= Math.floor(right));
    }
    _initSortingEvents(item) {
        if (!this._eventsInitialized) {
            this._setEvents(item);
            this._eventsInitialized = true;
        }
    }
    _removeSortingEvents() {
        this._draggables.forEach((item) => {
            const element = item._getHost();
            element.removeEventListener('mouseenter', this._mouseEnterHandler);
            element.style.transform = '';
            element.style.transition = '';
        });
    }
    _handleItemEnter(item, x, y) {
        this._eventsInitialized = false;
        this._cacheDraggables();
        const newIndex = this._getItemIndexFromCoordinates(x, y);
        const placeholder = item._getPlaceholder();
        let overItem = this._draggables[newIndex];
        let offsetLeft;
        let offsetTop;
        if (overItem) {
            const overItemElement = overItem._getHost();
            offsetLeft = overItemElement.offsetLeft;
            offsetTop = overItemElement.offsetTop;
            overItemElement.parentNode.insertBefore(placeholder, overItemElement);
            this._draggables.splice(newIndex, 0, item);
        }
        else {
            this.element.appendChild(placeholder);
            this._draggables.push(item);
        }
        placeholder.style.transform = '';
        this._cacheDraggables();
        if (overItem) {
            this._cachedDraggables[newIndex].offsetLeft = offsetLeft;
            this._cachedDraggables[newIndex].offsetTop = offsetTop;
        }
        else {
            const lastIndex = this._cachedDraggables.length - 1;
            this._cachedDraggables[lastIndex].offsetLeft = placeholder.offsetLeft;
            this._cachedDraggables[lastIndex].offsetTop = placeholder.offsetTop;
        }
        this._initSortingEvents(item);
    }
    _handleItemLeave(item) {
        const currentIndex = this._draggables.indexOf(item);
        this._draggables.splice(currentIndex, 1);
        this._removeSortingEvents();
    }
    _getItemIndexFromCoordinates(x, y) {
        return this._cachedDraggables.findIndex((draggable) => this._isPointerOverItem(draggable.rect, x, y));
    }
    _getContainerFromCoordinates(item, x, y) {
        return this.containers.find((container) => {
            if (container._canAcceptEnteringItem(item)) {
                return false;
            }
            const elementFromPoint = document.elementFromPoint(x, y);
            if (!elementFromPoint) {
                return false;
            }
            return container.element === elementFromPoint || container.element.contains(elementFromPoint);
        });
    }
    _canAcceptEnteringItem(item) {
        return !this.enterPredicate(item);
    }
    _setEvents(activeDraggable) {
        const inactiveSortItems = this._cachedDraggables.filter((draggable) => {
            if (draggable.instance === activeDraggable) {
                this._activeItem = draggable;
            }
            return draggable.instance !== activeDraggable;
        });
        this._inactiveItems = inactiveSortItems;
        if (!this.sortingDisabled) {
            inactiveSortItems.forEach((draggable) => {
                draggable.element.style.transition = `transform 300ms ease`;
                draggable.element.addEventListener('mouseenter', this._mouseEnterHandler);
            });
        }
    }
    _handleMouseEnter(event) {
        const enteredItem = this._getTarget(event);
        const itemBelow = enteredItem.index > this._activeItem.index;
        const itemsToMove = this._getItemsToMove(itemBelow, enteredItem);
        this._slideItems(itemBelow, itemsToMove);
        this._slideActiveItem(this._activeItem);
        this._activeItem.index = enteredItem.index;
        this._setIndexes(itemsToMove, itemBelow);
    }
    _getTarget(event) {
        return this._cachedDraggables.find((draggable) => draggable.element === event.target);
    }
    _slideItems(itemBelow, itemsToMove) {
        itemsToMove.forEach((item) => {
            const index = itemBelow ? item.index - 1 : item.index + 1;
            const adjacentItem = this._cachedDraggables[index];
            const distanceY = adjacentItem.offsetTop - item.offsetTop;
            const distanceX = adjacentItem.offsetLeft - item.offsetLeft;
            item.translateY = distanceY;
            item.translateX = distanceX;
            this._setTranslate(item.element, distanceX, distanceY);
        });
    }
    _slideActiveItem(item) {
        let sumY = 0;
        let sumX = 0;
        this._cachedDraggables.forEach((draggable) => {
            sumY -= draggable.translateY;
            sumX -= draggable.translateX;
        });
        const placeholder = item.instance._getPlaceholder();
        this._setTranslate(placeholder, sumX, sumY);
    }
    _getItemsToMove(itemBelow, enteredItem) {
        return this._cachedDraggables.filter((draggable) => {
            if (itemBelow) {
                return this._activeItem.index < draggable.index && draggable.index <= enteredItem.index;
            }
            return this._activeItem.index > draggable.index && draggable.index >= enteredItem.index;
        });
    }
    _setTranslate(element, x, y) {
        element.style.transform = `translate3d(${x}px, ${y}px, 0px)`;
    }
    _setIndexes(itemsToMove, itemBelow) {
        this._cachedDraggables = this._cachedDraggables.map((draggable) => {
            itemsToMove.forEach((item) => {
                if (draggable === item) {
                    if (itemBelow) {
                        item.index--;
                    }
                    else {
                        item.index++;
                    }
                }
            });
            return draggable;
        });
    }
    _setOffsets() {
        this._cachedDraggables.forEach((draggable) => {
            draggable.offsetLeft = draggable.element.offsetLeft;
            draggable.offsetTop = draggable.element.offsetTop;
        });
    }
    _resetTranslatesInfo() {
        this._cachedDraggables.forEach((draggable) => {
            draggable.translateX = 0;
            draggable.translateY = 0;
        });
    }
    _getDraggableIndex(item) {
        const correspondingItem = this._cachedDraggables.find((draggable) => draggable.instance === item);
        return correspondingItem.index;
    }
}
MdbSortableContainerDirective._sortableContainers = [];
MdbSortableContainerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.3", ngImport: i0, type: MdbSortableContainerDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
MdbSortableContainerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.2.3", type: MdbSortableContainerDirective, selector: "[mdbSortableContainer]", inputs: { autoScroll: "autoScroll", containers: "containers", data: "data", enterPredicate: "enterPredicate", id: "id", sortingDisabled: "sortingDisabled" }, outputs: { itemDrop: "itemDrop" }, providers: [{ provide: MDB_SORTABLE_CONTAINER, useExisting: MdbSortableContainerDirective }], queries: [{ propertyName: "draggables", predicate: MdbDraggableDirective }], exportAs: ["mdbSortableContainer"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.3", ngImport: i0, type: MdbSortableContainerDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[mdbSortableContainer]',
                    exportAs: 'mdbSortableContainer',
                    providers: [{ provide: MDB_SORTABLE_CONTAINER, useExisting: MdbSortableContainerDirective }],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { draggables: [{
                type: ContentChildren,
                args: [MdbDraggableDirective]
            }], autoScroll: [{
                type: Input
            }], containers: [{
                type: Input
            }], data: [{
                type: Input
            }], enterPredicate: [{
                type: Input
            }], id: [{
                type: Input
            }], sortingDisabled: [{
                type: Input
            }], itemDrop: [{
                type: Output
            }] } });

class MdbDragAndDropModule {
}
MdbDragAndDropModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.3", ngImport: i0, type: MdbDragAndDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MdbDragAndDropModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.2.3", ngImport: i0, type: MdbDragAndDropModule, declarations: [MdbDraggableDirective, MdbSortableContainerDirective], exports: [MdbDraggableDirective, MdbSortableContainerDirective] });
MdbDragAndDropModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.2.3", ngImport: i0, type: MdbDragAndDropModule, imports: [[]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.3", ngImport: i0, type: MdbDragAndDropModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MdbDraggableDirective, MdbSortableContainerDirective],
                    imports: [],
                    exports: [MdbDraggableDirective, MdbSortableContainerDirective],
                }]
        }] });

/*
 * Public API Surface of mdb-angular-drag-and-drop
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MDB_DRAGGABLE_PARENT, MDB_SORTABLE_CONTAINER, MdbDragAndDropModule, MdbDraggableDirective, MdbSortableContainerDirective, copyItemToNewContainer, moveItemToNewContainer, moveItemsInContainer };
//# sourceMappingURL=mdb-angular-drag-and-drop.mjs.map
