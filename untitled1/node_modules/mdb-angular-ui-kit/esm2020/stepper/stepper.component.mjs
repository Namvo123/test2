import { Component, ContentChildren, Input, ViewChild, ViewChildren, Output, EventEmitter, ChangeDetectionStrategy, } from '@angular/core';
import { MdbStepComponent } from './step.component';
import { FormControl } from '@angular/forms';
import { merge, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { horizontalAnimation, verticalAnimation } from './stepper-animations';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/cdk/portal";
export class MdbStepperComponent {
    constructor(_cdRef) {
        this._cdRef = _cdRef;
        this.orientation = 'horizontal';
        this._linear = false;
        this._mobile = false;
        this.mobileBarBreakpoint = 4;
        this._markAsCompleted = true;
        this.stepChange = new EventEmitter();
        this._destroy = new Subject();
    }
    get linear() {
        return this._linear;
    }
    set linear(value) {
        this._linear = coerceBooleanProperty(value);
    }
    get mobile() {
        return this._mobile;
    }
    set mobile(value) {
        this._mobile = coerceBooleanProperty(value);
    }
    get markAsCompleted() {
        return this._markAsCompleted;
    }
    set markAsCompleted(value) {
        this._markAsCompleted = coerceBooleanProperty(value);
    }
    get allStepsNumber() {
        return this.steps.length;
    }
    getProgressBarWidth() {
        return ((this.activeStepIndex + 1) / this.steps.length) * 100;
    }
    get activeStepIndex() {
        return this._activeStepIndex;
    }
    set activeStepIndex(value) {
        this._activeStepIndex = value;
    }
    _isStepValid(step) {
        if (!step.stepForm) {
            return true;
        }
        if (step.stepForm && step.stepForm.valid) {
            return true;
        }
        return false;
    }
    getAnimationState(index) {
        const nextElPosition = index - this.activeStepIndex;
        if (nextElPosition < 0) {
            return 'previous';
        }
        else if (nextElPosition > 0) {
            return 'next';
        }
        return 'current';
    }
    _getStepByIndex(index) {
        return this.steps.toArray()[index];
    }
    next() {
        if (this.activeStepIndex < this.steps.length - 1) {
            this.setNewActiveStep(this.activeStepIndex + 1);
            this._cdRef.markForCheck();
        }
    }
    previous() {
        if (this.activeStepIndex > 0) {
            this.setNewActiveStep(this.activeStepIndex - 1);
            this._cdRef.markForCheck();
        }
    }
    submit() {
        if (this.linear) {
            this._markCurrentAsDone();
            this._cdRef.markForCheck();
        }
    }
    setNewActiveStep(index) {
        setTimeout(() => {
            const currentStep = this._activeStep;
            const currentStepIndex = this._activeStepIndex;
            const newStep = this._getStepByIndex(index);
            const newStepIndex = this.steps
                .toArray()
                .findIndex((step) => step === newStep);
            if (this.linear && !this._isNewStepLinear(index)) {
                return;
            }
            if (newStepIndex < this._activeStepIndex && !newStep.editable) {
                return;
            }
            this._removeStepValidationClasses(newStep);
            if (this.linear && index > this.activeStepIndex) {
                if (this._isStepValid(this._activeStep) || currentStep.optional) {
                    this._markCurrentAsDone();
                    this._removeCurrentActiveStep();
                    this._setActiveStep(index);
                    this.stepChange.emit({
                        activeStep: newStep,
                        activeStepIndex: newStepIndex,
                        previousStep: currentStep,
                        previousStepIndex: currentStepIndex,
                    });
                }
                else {
                    this._markCurrentAsWrong();
                    this._markStepControlsAsDirty(this._activeStep);
                }
            }
            else {
                if (index < this.activeStepIndex) {
                    this._removeStepValidationClasses(this._activeStep);
                }
                this._removeCurrentActiveStep();
                this._markCurrentAsDone();
                this._setActiveStep(index);
                this.stepChange.emit({
                    activeStep: newStep,
                    activeStepIndex: newStepIndex,
                    previousStep: currentStep,
                    previousStepIndex: currentStepIndex,
                });
            }
        }, 0);
    }
    _markCurrentAsDone() {
        this._activeStep.isCompleted = true;
        this._activeStep.isInvalid = false;
    }
    _markCurrentAsWrong() {
        this._activeStep.isInvalid = true;
        this._activeStep.isCompleted = false;
    }
    _markStepControlsAsDirty(step) {
        const controls = step.stepForm.controls;
        if (step.stepForm.controls) {
            const keys = Object.keys(controls);
            // tslint:disable-next-line: prefer-for-of
            for (let i = 0; i < keys.length; i++) {
                const control = controls[keys[i]];
                if (control instanceof FormControl) {
                    control.markAsTouched();
                }
            }
        }
    }
    _removeStepValidationClasses(step) {
        step.isCompleted = false;
        step.isInvalid = false;
    }
    _isNewStepLinear(newStepIndex) {
        return this.activeStepIndex - newStepIndex === 1 || this.activeStepIndex - newStepIndex === -1;
    }
    _setActiveStep(index) {
        this.steps.toArray()[index].isActive = true;
        this.activeStepIndex = index;
        this._activeStep = this._getStepByIndex(this.activeStepIndex);
        this._cdRef.markForCheck();
    }
    _removeCurrentActiveStep() {
        const currentActiveStep = this.steps.find((activeStep) => activeStep.isActive);
        if (currentActiveStep) {
            currentActiveStep.isActive = false;
        }
    }
    resetAll() {
        this.steps.forEach((step) => {
            step.reset();
            this._setActiveStep(0);
            this._cdRef.markForCheck();
        });
    }
    ngAfterContentInit() {
        this._setActiveStep(0);
        // tslint:disable-next-line: deprecation
        this.steps.changes.pipe(takeUntil(this._destroy)).subscribe(() => this._cdRef.markForCheck());
        merge(...this.steps.map((step) => step._onChanges))
            .pipe(takeUntil(this._destroy))
            // tslint:disable-next-line: deprecation
            .subscribe((_) => this._cdRef.markForCheck());
    }
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
}
MdbStepperComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbStepperComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
MdbStepperComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.7", type: MdbStepperComponent, selector: "mdb-stepper", inputs: { orientation: "orientation", linear: "linear", mobile: "mobile", mobileBarBreakpoint: "mobileBarBreakpoint", markAsCompleted: "markAsCompleted" }, outputs: { stepChange: "stepChange" }, queries: [{ propertyName: "steps", predicate: MdbStepComponent }], viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, static: true }, { propertyName: "stepTitles", predicate: ["stepTitle"], descendants: true }, { propertyName: "stepContents", predicate: ["stepContent"], descendants: true }], exportAs: ["mdbStepper"], ngImport: i0, template: "<ng-container [ngSwitch]=\"orientation\">\n  <ng-container *ngSwitchCase=\"'horizontal'\">\n    <div *ngIf=\"mobile\" class=\"stepper-mobile-head bg-light\">\n      Step {{ activeStepIndex + 1 }} of {{ allStepsNumber }}\n    </div>\n    <ul\n      class=\"stepper stepper-horizontal\"\n      [ngClass]=\"{\n        'stepper-mobile': mobile,\n        'stepper-progress-bar': mobile && steps.length > mobileBarBreakpoint\n      }\"\n    >\n      <li\n        [ngClass]=\"{\n          'stepper-active': step.isActive,\n          'stepper-completed': step.isCompleted,\n          'stepper-invalid': step.isInvalid\n        }\"\n        class=\"stepper-step\"\n        *ngFor=\"let step of steps; let i = index\"\n      >\n        <div class=\"stepper-head\" (click)=\"setNewActiveStep(i)\">\n          <span class=\"stepper-head-icon\">\n            <ng-container *ngIf=\"!step.icon\">{{ i + 1 }}</ng-container>\n            <ng-template [ngIf]=\"step.icon\">\n              <ng-template [cdkPortalOutlet]=\"step.icon\"></ng-template>\n            </ng-template>\n          </span>\n          <span class=\"stepper-head-text\">{{ step.name }}</span>\n        </div>\n      </li>\n    </ul>\n    <div class=\"stepper-horizontal-content-container\">\n      <ng-container *ngFor=\"let step of steps; let i = index\">\n        <div\n          class=\"stepper-content\"\n          [attr.aria-expanded]=\"activeStepIndex === i\"\n          [@horizontalAnimation]=\"getAnimationState(i)\"\n        >\n          <ng-container [ngTemplateOutlet]=\"step.content\"></ng-container>\n        </div>\n      </ng-container>\n    </div>\n    <div *ngIf=\"mobile\" class=\"stepper-mobile-footer bg-light\">\n      <div class=\"stepper-back-btn\">\n        <button (click)=\"previous()\" type=\"button\" class=\"btn btn-link\">\n          <i class=\"fas fa-chevron-left\"></i>Back\n        </button>\n      </div>\n      <div *ngIf=\"steps.length > mobileBarBreakpoint\" class=\"stepper-mobile-progress gray-500\">\n        <div\n          class=\"stepper-mobile-progress-bar bg-primary\"\n          [style.width.%]=\"getProgressBarWidth()\"\n        ></div>\n      </div>\n      <div class=\"stepper-next-btn\">\n        <button (click)=\"next()\" type=\"button\" class=\"btn btn-link\">\n          Next<i class=\"fas fa-chevron-right\"></i>\n        </button>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"'vertical'\">\n    <ul class=\"stepper stepper-vertical\">\n      <li\n        [ngClass]=\"{\n          'stepper-active': step.isActive,\n          'stepper-completed': step.isCompleted,\n          'stepper-invalid': step.isInvalid\n        }\"\n        class=\"stepper-step\"\n        *ngFor=\"let step of steps; let i = index\"\n      >\n        <div class=\"stepper-head\" (click)=\"setNewActiveStep(i)\">\n          <span class=\"stepper-head-icon\">\n            <ng-container *ngIf=\"!step.icon\">{{ i + 1 }}</ng-container>\n            <ng-template [ngIf]=\"step.icon\">\n              <ng-template [cdkPortalOutlet]=\"step.icon\"></ng-template>\n            </ng-template>\n          </span>\n          <span class=\"stepper-head-text\">{{ step.name }}</span>\n        </div>\n        <div class=\"stepper-vertical-content-container\" [@verticalAnimation]=\"getAnimationState(i)\">\n          <div class=\"stepper-content\">\n            <ng-container [ngTemplateOutlet]=\"step.content\"></ng-container>\n          </div>\n        </div>\n      </li>\n    </ul>\n  </ng-container>\n</ng-container>\n", directives: [{ type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.CdkPortalOutlet, selector: "[cdkPortalOutlet]", inputs: ["cdkPortalOutlet"], outputs: ["attached"], exportAs: ["cdkPortalOutlet"] }, { type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], animations: [horizontalAnimation, verticalAnimation], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbStepperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'mdb-stepper', exportAs: 'mdbStepper', animations: [horizontalAnimation, verticalAnimation], changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container [ngSwitch]=\"orientation\">\n  <ng-container *ngSwitchCase=\"'horizontal'\">\n    <div *ngIf=\"mobile\" class=\"stepper-mobile-head bg-light\">\n      Step {{ activeStepIndex + 1 }} of {{ allStepsNumber }}\n    </div>\n    <ul\n      class=\"stepper stepper-horizontal\"\n      [ngClass]=\"{\n        'stepper-mobile': mobile,\n        'stepper-progress-bar': mobile && steps.length > mobileBarBreakpoint\n      }\"\n    >\n      <li\n        [ngClass]=\"{\n          'stepper-active': step.isActive,\n          'stepper-completed': step.isCompleted,\n          'stepper-invalid': step.isInvalid\n        }\"\n        class=\"stepper-step\"\n        *ngFor=\"let step of steps; let i = index\"\n      >\n        <div class=\"stepper-head\" (click)=\"setNewActiveStep(i)\">\n          <span class=\"stepper-head-icon\">\n            <ng-container *ngIf=\"!step.icon\">{{ i + 1 }}</ng-container>\n            <ng-template [ngIf]=\"step.icon\">\n              <ng-template [cdkPortalOutlet]=\"step.icon\"></ng-template>\n            </ng-template>\n          </span>\n          <span class=\"stepper-head-text\">{{ step.name }}</span>\n        </div>\n      </li>\n    </ul>\n    <div class=\"stepper-horizontal-content-container\">\n      <ng-container *ngFor=\"let step of steps; let i = index\">\n        <div\n          class=\"stepper-content\"\n          [attr.aria-expanded]=\"activeStepIndex === i\"\n          [@horizontalAnimation]=\"getAnimationState(i)\"\n        >\n          <ng-container [ngTemplateOutlet]=\"step.content\"></ng-container>\n        </div>\n      </ng-container>\n    </div>\n    <div *ngIf=\"mobile\" class=\"stepper-mobile-footer bg-light\">\n      <div class=\"stepper-back-btn\">\n        <button (click)=\"previous()\" type=\"button\" class=\"btn btn-link\">\n          <i class=\"fas fa-chevron-left\"></i>Back\n        </button>\n      </div>\n      <div *ngIf=\"steps.length > mobileBarBreakpoint\" class=\"stepper-mobile-progress gray-500\">\n        <div\n          class=\"stepper-mobile-progress-bar bg-primary\"\n          [style.width.%]=\"getProgressBarWidth()\"\n        ></div>\n      </div>\n      <div class=\"stepper-next-btn\">\n        <button (click)=\"next()\" type=\"button\" class=\"btn btn-link\">\n          Next<i class=\"fas fa-chevron-right\"></i>\n        </button>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"'vertical'\">\n    <ul class=\"stepper stepper-vertical\">\n      <li\n        [ngClass]=\"{\n          'stepper-active': step.isActive,\n          'stepper-completed': step.isCompleted,\n          'stepper-invalid': step.isInvalid\n        }\"\n        class=\"stepper-step\"\n        *ngFor=\"let step of steps; let i = index\"\n      >\n        <div class=\"stepper-head\" (click)=\"setNewActiveStep(i)\">\n          <span class=\"stepper-head-icon\">\n            <ng-container *ngIf=\"!step.icon\">{{ i + 1 }}</ng-container>\n            <ng-template [ngIf]=\"step.icon\">\n              <ng-template [cdkPortalOutlet]=\"step.icon\"></ng-template>\n            </ng-template>\n          </span>\n          <span class=\"stepper-head-text\">{{ step.name }}</span>\n        </div>\n        <div class=\"stepper-vertical-content-container\" [@verticalAnimation]=\"getAnimationState(i)\">\n          <div class=\"stepper-content\">\n            <ng-container [ngTemplateOutlet]=\"step.content\"></ng-container>\n          </div>\n        </div>\n      </li>\n    </ul>\n  </ng-container>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { steps: [{
                type: ContentChildren,
                args: [MdbStepComponent]
            }], stepTitles: [{
                type: ViewChildren,
                args: ['stepTitle']
            }], stepContents: [{
                type: ViewChildren,
                args: ['stepContent']
            }], container: [{
                type: ViewChild,
                args: ['container', { static: true }]
            }], orientation: [{
                type: Input
            }], linear: [{
                type: Input
            }], mobile: [{
                type: Input
            }], mobileBarBreakpoint: [{
                type: Input
            }], markAsCompleted: [{
                type: Input
            }], stepChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9tZGItYW5ndWxhci11aS1raXQvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL3Byb2plY3RzL21kYi1hbmd1bGFyLXVpLWtpdC9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxlQUFlLEVBR2YsS0FBSyxFQUVMLFNBQVMsRUFDVCxZQUFZLEVBQ1osTUFBTSxFQUNOLFlBQVksRUFFWix1QkFBdUIsR0FFeEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM5RSxPQUFPLEVBQWdCLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7QUFtQjVFLE1BQU0sT0FBTyxtQkFBbUI7SUFxQzlCLFlBQW9CLE1BQXlCO1FBQXpCLFdBQU0sR0FBTixNQUFNLENBQW1CO1FBL0JwQyxnQkFBVyxHQUEwQixZQUFZLENBQUM7UUFRbkQsWUFBTyxHQUFHLEtBQUssQ0FBQztRQVNoQixZQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ2Ysd0JBQW1CLEdBQUcsQ0FBQyxDQUFDO1FBU3pCLHFCQUFnQixHQUFHLElBQUksQ0FBQztRQUV0QixlQUFVLEdBQXFDLElBQUksWUFBWSxFQUFzQixDQUFDO1FBSXhGLGFBQVEsR0FBa0Is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LDJVQ3hDbkMseThHQTRGQSxnc0JEeERjLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUM7MkZBR3pDLG1CQUFtQjtrQkFSL0IsU0FBUzsrQkFFRSxhQUFhLFlBQ2IsWUFBWSxjQUVWLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsbUJBQ25DLHVCQUF1QixDQUFDLE1BQU07d0dBR1osS0FBSztzQkFBdkMsZUFBZTt1QkFBQyxnQkFBZ0I7Z0JBQ04sVUFBVTtzQkFBcEMsWUFBWTt1QkFBQyxXQUFXO2dCQUNJLFlBQVk7c0JBQXhDLFlBQVk7dUJBQUMsYUFBYTtnQkFDZSxTQUFTO3NCQUFsRCxTQUFTO3VCQUFDLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBRS9CLFdBQVc7c0JBQW5CLEtBQUs7Z0JBRUYsTUFBTTtzQkFEVCxLQUFLO2dCQVVGLE1BQU07c0JBRFQsS0FBSztnQkFRRyxtQkFBbUI7c0JBQTNCLEtBQUs7Z0JBR0YsZUFBZTtzQkFEbEIsS0FBSztnQkFTSSxVQUFVO3NCQUFuQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIFF1ZXJ5TGlzdCxcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgSW5wdXQsXG4gIEVsZW1lbnRSZWYsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NoaWxkcmVuLFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgT25EZXN0cm95LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWRiU3RlcENvbXBvbmVudCB9IGZyb20gJy4vc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBtZXJnZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgaG9yaXpvbnRhbEFuaW1hdGlvbiwgdmVydGljYWxBbmltYXRpb24gfSBmcm9tICcuL3N0ZXBwZXItYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBCb29sZWFuSW5wdXQsIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5cbmV4cG9ydCB0eXBlIE1kYlN0ZXBwZXJPcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWRiU3RlcENoYW5nZUV2ZW50IHtcbiAgYWN0aXZlU3RlcDogTWRiU3RlcENvbXBvbmVudDtcbiAgYWN0aXZlU3RlcEluZGV4OiBudW1iZXI7XG4gIHByZXZpb3VzU3RlcDogTWRiU3RlcENvbXBvbmVudDtcbiAgcHJldmlvdXNTdGVwSW5kZXg6IG51bWJlcjtcbn1cblxuQENvbXBvbmVudCh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogY29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnbWRiLXN0ZXBwZXInLFxuICBleHBvcnRBczogJ21kYlN0ZXBwZXInLFxuICB0ZW1wbGF0ZVVybDogJ3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwnLFxuICBhbmltYXRpb25zOiBbaG9yaXpvbnRhbEFuaW1hdGlvbiwgdmVydGljYWxBbmltYXRpb25dLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTWRiU3RlcHBlckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIEBDb250ZW50Q2hpbGRyZW4oTWRiU3RlcENvbXBvbmVudCkgc3RlcHM6IFF1ZXJ5TGlzdDxNZGJTdGVwQ29tcG9uZW50PjtcbiAgQFZpZXdDaGlsZHJlbignc3RlcFRpdGxlJykgc3RlcFRpdGxlczogUXVlcnlMaXN0PEVsZW1lbnRSZWY+O1xuICBAVmlld0NoaWxkcmVuKCdzdGVwQ29udGVudCcpIHN0ZXBDb250ZW50czogUXVlcnlMaXN0PEVsZW1lbnRSZWY+O1xuICBAVmlld0NoaWxkKCdjb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KSBjb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgQElucHV0KCkgb3JpZW50YXRpb246IE1kYlN0ZXBwZXJPcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgQElucHV0KClcbiAgZ2V0IGxpbmVhcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZWFyO1xuICB9XG4gIHNldCBsaW5lYXIodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9saW5lYXIgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG4gIHByaXZhdGUgX2xpbmVhciA9IGZhbHNlO1xuXG4gIEBJbnB1dCgpXG4gIGdldCBtb2JpbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX21vYmlsZTtcbiAgfVxuICBzZXQgbW9iaWxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fbW9iaWxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBwcml2YXRlIF9tb2JpbGUgPSBmYWxzZTtcbiAgQElucHV0KCkgbW9iaWxlQmFyQnJlYWtwb2ludCA9IDQ7XG5cbiAgQElucHV0KClcbiAgZ2V0IG1hcmtBc0NvbXBsZXRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya0FzQ29tcGxldGVkO1xuICB9XG4gIHNldCBtYXJrQXNDb21wbGV0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9tYXJrQXNDb21wbGV0ZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG4gIHByaXZhdGUgX21hcmtBc0NvbXBsZXRlZCA9IHRydWU7XG5cbiAgQE91dHB1dCgpIHN0ZXBDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNZGJTdGVwQ2hhbmdlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNZGJTdGVwQ2hhbmdlRXZlbnQ+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2RSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7fVxuXG4gIHByaXZhdGUgX2Rlc3Ryb3k6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIHByaXZhdGUgX2FjdGl2ZVN0ZXBJbmRleDogbnVtYmVyO1xuICBwcml2YXRlIF9hY3RpdmVTdGVwOiBNZGJTdGVwQ29tcG9uZW50O1xuXG4gIGdldCBhbGxTdGVwc051bWJlcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgfVxuXG4gIGdldFByb2dyZXNzQmFyV2lkdGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKCh0aGlzLmFjdGl2ZVN0ZXBJbmRleCArIDEpIC8gdGhpcy5zdGVwcy5sZW5ndGgpICogMTAwO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZVN0ZXBJbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVTdGVwSW5kZXg7XG4gIH1cblxuICBzZXQgYWN0aXZlU3RlcEluZGV4KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgX2lzU3RlcFZhbGlkKHN0ZXA6IE1kYlN0ZXBDb21wb25lbnQpOiBib29sZWFuIHtcbiAgICBpZiAoIXN0ZXAuc3RlcEZvcm0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdGVwLnN0ZXBGb3JtICYmIHN0ZXAuc3RlcEZvcm0udmFsaWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldEFuaW1hdGlvblN0YXRlKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5leHRFbFBvc2l0aW9uID0gaW5kZXggLSB0aGlzLmFjdGl2ZVN0ZXBJbmRleDtcblxuICAgIGlmIChuZXh0RWxQb3NpdGlvbiA8IDApIHtcbiAgICAgIHJldHVybiAncHJldmlvdXMnO1xuICAgIH0gZWxzZSBpZiAobmV4dEVsUG9zaXRpb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ25leHQnO1xuICAgIH1cbiAgICByZXR1cm4gJ2N1cnJlbnQnO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0U3RlcEJ5SW5kZXgoaW5kZXg6IG51bWJlcik6IE1kYlN0ZXBDb21wb25lbnQge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLnRvQXJyYXkoKVtpbmRleF07XG4gIH1cblxuICBuZXh0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmFjdGl2ZVN0ZXBJbmRleCA8IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5zZXROZXdBY3RpdmVTdGVwKHRoaXMuYWN0aXZlU3RlcEluZGV4ICsgMSk7XG4gICAgICB0aGlzLl9jZFJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICBwcmV2aW91cygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hY3RpdmVTdGVwSW5kZXggPiAwKSB7XG4gICAgICB0aGlzLnNldE5ld0FjdGl2ZVN0ZXAodGhpcy5hY3RpdmVTdGVwSW5kZXggLSAxKTtcbiAgICAgIHRoaXMuX2NkUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgfVxuXG4gIHN1Ym1pdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5saW5lYXIpIHtcbiAgICAgIHRoaXMuX21hcmtDdXJyZW50QXNEb25lKCk7XG4gICAgICB0aGlzLl9jZFJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICBzZXROZXdBY3RpdmVTdGVwKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGVwID0gdGhpcy5fYWN0aXZlU3RlcDtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGVwSW5kZXggPSB0aGlzLl9hY3RpdmVTdGVwSW5kZXg7XG4gICAgICBjb25zdCBuZXdTdGVwID0gdGhpcy5fZ2V0U3RlcEJ5SW5kZXgoaW5kZXgpO1xuICAgICAgY29uc3QgbmV3U3RlcEluZGV4ID0gdGhpcy5zdGVwc1xuICAgICAgICAudG9BcnJheSgpXG4gICAgICAgIC5maW5kSW5kZXgoKHN0ZXA6IE1kYlN0ZXBDb21wb25lbnQpID0+IHN0ZXAgPT09IG5ld1N0ZXApO1xuXG4gICAgICBpZiAodGhpcy5saW5lYXIgJiYgIXRoaXMuX2lzTmV3U3RlcExpbmVhcihpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3U3RlcEluZGV4IDwgdGhpcy5fYWN0aXZlU3RlcEluZGV4ICYmICFuZXdTdGVwLmVkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVtb3ZlU3RlcFZhbGlkYXRpb25DbGFzc2VzKG5ld1N0ZXApO1xuXG4gICAgICBpZiAodGhpcy5saW5lYXIgJiYgaW5kZXggPiB0aGlzLmFjdGl2ZVN0ZXBJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5faXNTdGVwVmFsaWQodGhpcy5fYWN0aXZlU3RlcCkgfHwgY3VycmVudFN0ZXAub3B0aW9uYWwpIHtcbiAgICAgICAgICB0aGlzLl9tYXJrQ3VycmVudEFzRG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUN1cnJlbnRBY3RpdmVTdGVwKCk7XG4gICAgICAgICAgdGhpcy5fc2V0QWN0aXZlU3RlcChpbmRleCk7XG5cbiAgICAgICAgICB0aGlzLnN0ZXBDaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBhY3RpdmVTdGVwOiBuZXdTdGVwLFxuICAgICAgICAgICAgYWN0aXZlU3RlcEluZGV4OiBuZXdTdGVwSW5kZXgsXG4gICAgICAgICAgICBwcmV2aW91c1N0ZXA6IGN1cnJlbnRTdGVwLFxuICAgICAgICAgICAgcHJldmlvdXNTdGVwSW5kZXg6IGN1cnJlbnRTdGVwSW5kZXgsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbWFya0N1cnJlbnRBc1dyb25nKCk7XG4gICAgICAgICAgdGhpcy5fbWFya1N0ZXBDb250cm9sc0FzRGlydHkodGhpcy5fYWN0aXZlU3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuYWN0aXZlU3RlcEluZGV4KSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3RlcFZhbGlkYXRpb25DbGFzc2VzKHRoaXMuX2FjdGl2ZVN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlQ3VycmVudEFjdGl2ZVN0ZXAoKTtcbiAgICAgICAgdGhpcy5fbWFya0N1cnJlbnRBc0RvbmUoKTtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlU3RlcChpbmRleCk7XG5cbiAgICAgICAgdGhpcy5zdGVwQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgIGFjdGl2ZVN0ZXA6IG5ld1N0ZXAsXG4gICAgICAgICAgYWN0aXZlU3RlcEluZGV4OiBuZXdTdGVwSW5kZXgsXG4gICAgICAgICAgcHJldmlvdXNTdGVwOiBjdXJyZW50U3RlcCxcbiAgICAgICAgICBwcmV2aW91c1N0ZXBJbmRleDogY3VycmVudFN0ZXBJbmRleCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cblxuICBwcml2YXRlIF9tYXJrQ3VycmVudEFzRG9uZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3RpdmVTdGVwLmlzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9hY3RpdmVTdGVwLmlzSW52YWxpZCA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBfbWFya0N1cnJlbnRBc1dyb25nKCk6IHZvaWQge1xuICAgIHRoaXMuX2FjdGl2ZVN0ZXAuaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLl9hY3RpdmVTdGVwLmlzQ29tcGxldGVkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIF9tYXJrU3RlcENvbnRyb2xzQXNEaXJ0eShzdGVwOiBNZGJTdGVwQ29tcG9uZW50KTogdm9pZCB7XG4gICAgY29uc3QgY29udHJvbHMgPSBzdGVwLnN0ZXBGb3JtLmNvbnRyb2xzO1xuICAgIGlmIChzdGVwLnN0ZXBGb3JtLmNvbnRyb2xzKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY29udHJvbHMpO1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItZm9yLW9mXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29udHJvbCA9IGNvbnRyb2xzW2tleXNbaV1dO1xuXG4gICAgICAgIGlmIChjb250cm9sIGluc3RhbmNlb2YgRm9ybUNvbnRyb2wpIHtcbiAgICAgICAgICBjb250cm9sLm1hcmtBc1RvdWNoZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3JlbW92ZVN0ZXBWYWxpZGF0aW9uQ2xhc3NlcyhzdGVwOiBNZGJTdGVwQ29tcG9uZW50KTogdm9pZCB7XG4gICAgc3RlcC5pc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgIHN0ZXAuaXNJbnZhbGlkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIF9pc05ld1N0ZXBMaW5lYXIobmV3U3RlcEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTdGVwSW5kZXggLSBuZXdTdGVwSW5kZXggPT09IDEgfHwgdGhpcy5hY3RpdmVTdGVwSW5kZXggLSBuZXdTdGVwSW5kZXggPT09IC0xO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2V0QWN0aXZlU3RlcChpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zdGVwcy50b0FycmF5KClbaW5kZXhdLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmFjdGl2ZVN0ZXBJbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX2FjdGl2ZVN0ZXAgPSB0aGlzLl9nZXRTdGVwQnlJbmRleCh0aGlzLmFjdGl2ZVN0ZXBJbmRleCk7XG4gICAgdGhpcy5fY2RSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBwcml2YXRlIF9yZW1vdmVDdXJyZW50QWN0aXZlU3RlcCgpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50QWN0aXZlU3RlcCA9IHRoaXMuc3RlcHMuZmluZCgoYWN0aXZlU3RlcCkgPT4gYWN0aXZlU3RlcC5pc0FjdGl2ZSk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmVTdGVwKSB7XG4gICAgICBjdXJyZW50QWN0aXZlU3RlcC5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0QWxsKCk6IHZvaWQge1xuICAgIHRoaXMuc3RlcHMuZm9yRWFjaCgoc3RlcDogTWRiU3RlcENvbXBvbmVudCkgPT4ge1xuICAgICAgc3RlcC5yZXNldCgpO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlU3RlcCgwKTtcbiAgICAgIHRoaXMuX2NkUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgIHRoaXMuX3NldEFjdGl2ZVN0ZXAoMCk7XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgdGhpcy5zdGVwcy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fY2RSZWYubWFya0ZvckNoZWNrKCkpO1xuXG4gICAgbWVyZ2UoLi4udGhpcy5zdGVwcy5tYXAoKHN0ZXA6IE1kYlN0ZXBDb21wb25lbnQpID0+IHN0ZXAuX29uQ2hhbmdlcykpXG4gICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgICAuc3Vic2NyaWJlKChfKSA9PiB0aGlzLl9jZFJlZi5tYXJrRm9yQ2hlY2soKSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9kZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbGluZWFyOiBCb29sZWFuSW5wdXQ7XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9tb2JpbGU6IEJvb2xlYW5JbnB1dDtcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX21hcmtBc0NvbXBsZXRlZDogQm9vbGVhbklucHV0O1xufVxuIiwiPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwib3JpZW50YXRpb25cIj5cbiAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVwiJ2hvcml6b250YWwnXCI+XG4gICAgPGRpdiAqbmdJZj1cIm1vYmlsZVwiIGNsYXNzPVwic3RlcHBlci1tb2JpbGUtaGVhZCBiZy1saWdodFwiPlxuICAgICAgU3RlcCB7eyBhY3RpdmVTdGVwSW5kZXggKyAxIH19IG9mIHt7IGFsbFN0ZXBzTnVtYmVyIH19XG4gICAgPC9kaXY+XG4gICAgPHVsXG4gICAgICBjbGFzcz1cInN0ZXBwZXIgc3RlcHBlci1ob3Jpem9udGFsXCJcbiAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgJ3N0ZXBwZXItbW9iaWxlJzogbW9iaWxlLFxuICAgICAgICAnc3RlcHBlci1wcm9ncmVzcy1iYXInOiBtb2JpbGUgJiYgc3RlcHMubGVuZ3RoID4gbW9iaWxlQmFyQnJlYWtwb2ludFxuICAgICAgfVwiXG4gICAgPlxuICAgICAgPGxpXG4gICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAnc3RlcHBlci1hY3RpdmUnOiBzdGVwLmlzQWN0aXZlLFxuICAgICAgICAgICdzdGVwcGVyLWNvbXBsZXRlZCc6IHN0ZXAuaXNDb21wbGV0ZWQsXG4gICAgICAgICAgJ3N0ZXBwZXItaW52YWxpZCc6IHN0ZXAuaXNJbnZhbGlkXG4gICAgICAgIH1cIlxuICAgICAgICBjbGFzcz1cInN0ZXBwZXItc3RlcFwiXG4gICAgICAgICpuZ0Zvcj1cImxldCBzdGVwIG9mIHN0ZXBzOyBsZXQgaSA9IGluZGV4XCJcbiAgICAgID5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN0ZXBwZXItaGVhZFwiIChjbGljayk9XCJzZXROZXdBY3RpdmVTdGVwKGkpXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGVwcGVyLWhlYWQtaWNvblwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFzdGVwLmljb25cIj57eyBpICsgMSB9fTwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cInN0ZXAuaWNvblwiPlxuICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW2Nka1BvcnRhbE91dGxldF09XCJzdGVwLmljb25cIj48L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGVwcGVyLWhlYWQtdGV4dFwiPnt7IHN0ZXAubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gICAgPGRpdiBjbGFzcz1cInN0ZXBwZXItaG9yaXpvbnRhbC1jb250ZW50LWNvbnRhaW5lclwiPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwczsgbGV0IGkgPSBpbmRleFwiPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3M9XCJzdGVwcGVyLWNvbnRlbnRcIlxuICAgICAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiYWN0aXZlU3RlcEluZGV4ID09PSBpXCJcbiAgICAgICAgICBbQGhvcml6b250YWxBbmltYXRpb25dPVwiZ2V0QW5pbWF0aW9uU3RhdGUoaSlcIlxuICAgICAgICA+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJzdGVwLmNvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2ICpuZ0lmPVwibW9iaWxlXCIgY2xhc3M9XCJzdGVwcGVyLW1vYmlsZS1mb290ZXIgYmctbGlnaHRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzdGVwcGVyLWJhY2stYnRuXCI+XG4gICAgICAgIDxidXR0b24gKGNsaWNrKT1cInByZXZpb3VzKClcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmtcIj5cbiAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS1jaGV2cm9uLWxlZnRcIj48L2k+QmFja1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiAqbmdJZj1cInN0ZXBzLmxlbmd0aCA+IG1vYmlsZUJhckJyZWFrcG9pbnRcIiBjbGFzcz1cInN0ZXBwZXItbW9iaWxlLXByb2dyZXNzIGdyYXktNTAwXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzcz1cInN0ZXBwZXItbW9iaWxlLXByb2dyZXNzLWJhciBiZy1wcmltYXJ5XCJcbiAgICAgICAgICBbc3R5bGUud2lkdGguJV09XCJnZXRQcm9ncmVzc0JhcldpZHRoKClcIlxuICAgICAgICA+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzdGVwcGVyLW5leHQtYnRuXCI+XG4gICAgICAgIDxidXR0b24gKGNsaWNrKT1cIm5leHQoKVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tbGlua1wiPlxuICAgICAgICAgIE5leHQ8aSBjbGFzcz1cImZhcyBmYS1jaGV2cm9uLXJpZ2h0XCI+PC9pPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L25nLWNvbnRhaW5lcj5cblxuICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCIndmVydGljYWwnXCI+XG4gICAgPHVsIGNsYXNzPVwic3RlcHBlciBzdGVwcGVyLXZlcnRpY2FsXCI+XG4gICAgICA8bGlcbiAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICdzdGVwcGVyLWFjdGl2ZSc6IHN0ZXAuaXNBY3RpdmUsXG4gICAgICAgICAgJ3N0ZXBwZXItY29tcGxldGVkJzogc3RlcC5pc0NvbXBsZXRlZCxcbiAgICAgICAgICAnc3RlcHBlci1pbnZhbGlkJzogc3RlcC5pc0ludmFsaWRcbiAgICAgICAgfVwiXG4gICAgICAgIGNsYXNzPVwic3RlcHBlci1zdGVwXCJcbiAgICAgICAgKm5nRm9yPVwibGV0IHN0ZXAgb2Ygc3RlcHM7IGxldCBpID0gaW5kZXhcIlxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3RlcHBlci1oZWFkXCIgKGNsaWNrKT1cInNldE5ld0FjdGl2ZVN0ZXAoaSlcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0ZXBwZXItaGVhZC1pY29uXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXN0ZXAuaWNvblwiPnt7IGkgKyAxIH19PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwic3RlcC5pY29uXCI+XG4gICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbY2RrUG9ydGFsT3V0bGV0XT1cInN0ZXAuaWNvblwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0ZXBwZXItaGVhZC10ZXh0XCI+e3sgc3RlcC5uYW1lIH19PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN0ZXBwZXItdmVydGljYWwtY29udGVudC1jb250YWluZXJcIiBbQHZlcnRpY2FsQW5pbWF0aW9uXT1cImdldEFuaW1hdGlvblN0YXRlKGkpXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInN0ZXBwZXItY29udGVudFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJzdGVwLmNvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gIDwvbmctY29udGFpbmVyPlxuPC9uZy1jb250YWluZXI+XG4iXX0=