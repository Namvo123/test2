import * as i1$1 from '@angular/cdk/overlay';
import { OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import * as i0 from '@angular/core';
import { Component, Input, EventEmitter, ViewChildren, ViewChild, Output, HostListener, Directive, NgModule } from '@angular/core';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { trigger, transition, query, animateChild, state, style, animate } from '@angular/animations';
import { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';
import { ComponentPortal } from '@angular/cdk/portal';
import { Subject, fromEvent } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';

class MdbMentionItemComponent {
    constructor() {
        this.optionHeight = 35;
        this.showImg = false;
        this.mentionValue = '';
        this.active = false;
    }
    setActiveStyles() {
        if (!this.active) {
            this.active = true;
        }
    }
    setInactiveStyles() {
        if (this.active) {
            this.active = false;
        }
    }
    highlightMatchingLetters(itemName) {
        const matchingLetters = new RegExp(`(?<captureGroup>${this.mentionValue})`, 'gi');
        return itemName.replace(matchingLetters, '<strong>$<captureGroup></strong>');
    }
}
MdbMentionItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MdbMentionItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.7", type: MdbMentionItemComponent, selector: "mention-item", inputs: { item: "item", queryBy: "queryBy", optionHeight: "optionHeight", showImg: "showImg", mentionValue: "mentionValue" }, ngImport: i0, template: "<li #mentionItem\n    [ngStyle]=\"{'height': optionHeight + 'px'}\"\n    [ngClass]=\"{'active': active}\"\n    class=\"mention-item\">\n    <span\n    [innerHTML]=\"highlightMatchingLetters(item[queryBy])\"\n    ></span>\n    <img *ngIf=\"item.image && item.image !== '' && showImg\" [src]=\"item.image\" class=\"mention-item-image rounded-circle\">\n</li>", directives: [{ type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'mention-item', styles: [], template: "<li #mentionItem\n    [ngStyle]=\"{'height': optionHeight + 'px'}\"\n    [ngClass]=\"{'active': active}\"\n    class=\"mention-item\">\n    <span\n    [innerHTML]=\"highlightMatchingLetters(item[queryBy])\"\n    ></span>\n    <img *ngIf=\"item.image && item.image !== '' && showImg\" [src]=\"item.image\" class=\"mention-item-image rounded-circle\">\n</li>" }]
        }], ctorParameters: function () { return []; }, propDecorators: { item: [{
                type: Input
            }], queryBy: [{
                type: Input
            }], optionHeight: [{
                type: Input
            }], showImg: [{
                type: Input
            }], mentionValue: [{
                type: Input
            }] } });

const dropdownContainerAnimation = trigger('dropdownContainerAnimation', [
    transition('* => void', [query('@*', [animateChild()], { optional: true })]),
]);
const dropdownAnimation = trigger('dropdownAnimation', [
    state('void', style({
        transform: 'scaleY(0.9)',
        opacity: 0,
    })),
    state('visible', style({
        opacity: 1,
        transform: 'scaleY(1)',
    })),
    transition('void => *', animate('300ms ease')),
    transition('* => void', animate('300ms ease')),
]);

class MdbMentionComponent {
    constructor() {
        this.optionHeight = 35;
        this.noResultText = 'No result found';
        this.visibleItems = 5;
        this.items = [];
        this.queryBy = 'username';
        this.showNoResultText = true;
        this.asyncError = false;
        this.showImg = false;
        this.mentionValue = '';
        this.optionClick = new EventEmitter();
        this.tabout = new EventEmitter();
    }
    ngAfterViewInit() {
        this.keyManager = new ActiveDescendantKeyManager(this.options);
        setTimeout(() => {
            this.keyManager.setFirstItemActive();
        }, 0);
        this.options.changes.subscribe(() => {
            setTimeout(() => {
                this.keyManager.setFirstItemActive();
            }, 0);
        });
        this.keyManager.tabOut.subscribe(() => {
            this.tabout.emit();
        });
    }
    handleKeyDown(event) {
        if (!this.items) {
            return;
        }
        const key = event.code;
        this.keyManager.onKeydown(event);
        switch (key) {
            case 'Home':
                this.keyManager.setFirstItemActive();
                break;
            case 'End':
                this.keyManager.setLastItemActive();
                break;
            case 'Enter':
                const activeItem = this.keyManager.activeItem.item;
                this.handleOptionClick(activeItem);
                break;
        }
        this._moveHighlightedIntoView();
    }
    handleOptionClick(item) {
        this.optionClick.emit(item);
    }
    _setScrollTop(scrollPosition) {
        if (this._dropdownList) {
            this._dropdownList.nativeElement.scrollTop = scrollPosition;
        }
    }
    _moveHighlightedIntoView() {
        const index = this.keyManager.activeItemIndex;
        if (index === 0) {
            this._setScrollTop(0);
        }
        else if (index && index > -1) {
            let newScrollPosition;
            const optionHeight = this.optionHeight;
            const listHeight = this._dropdownList.nativeElement.clientHeight;
            const itemTop = index * optionHeight;
            const itemBottom = itemTop + optionHeight;
            const viewTop = this._dropdownList.nativeElement.scrollTop;
            const viewBottom = viewTop + listHeight;
            if (itemBottom > viewBottom) {
                newScrollPosition = itemBottom - listHeight;
                this._setScrollTop(newScrollPosition);
            }
            else if (itemTop < viewTop) {
                newScrollPosition = itemTop;
                this._setScrollTop(newScrollPosition);
            }
        }
    }
}
MdbMentionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MdbMentionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.7", type: MdbMentionComponent, selector: "mdb-mention", inputs: { optionHeight: "optionHeight" }, outputs: { optionClick: "optionClick", tabout: "tabout" }, host: { listeners: { "window:keydown": "handleKeyDown($event)" } }, viewQueries: [{ propertyName: "_dropdownList", first: true, predicate: ["dropdownList"], descendants: true }, { propertyName: "options", predicate: MdbMentionItemComponent, descendants: true }], ngImport: i0, template: "<div [@dropdownContainerAnimation] class=\"mention-dropdown-container\" >\n    <div [@dropdownAnimation] role=\"listbox\" class=\"mention-dropdown\">\n      <ul class=\"mention-items-list\" #dropdownList\n        [ngStyle]=\"{'max-height': optionHeight * visibleItems + 'px'}\">\n        <mention-item\n        *ngFor=\"let item of items\"\n        [mentionValue]=\"mentionValue\"\n        [showImg]=\"showImg\"\n        [queryBy]=\"queryBy\"\n        [optionHeight]=\"optionHeight\"\n        [item]=\"item\"\n        (click)=\"handleOptionClick(item)\"></mention-item>\n        <li\n        *ngIf=\"(items.length === 0 && showNoResultText) || asyncError\"\n        [ngStyle]=\"{'min-height': optionHeight + 'px'}\"\n        class=\"mention-result\">\n        {{ noResultText }}\n      </li>\n      </ul>\n    </div>\n  </div>", components: [{ type: MdbMentionItemComponent, selector: "mention-item", inputs: ["item", "queryBy", "optionHeight", "showImg", "mentionValue"] }], directives: [{ type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], animations: [dropdownAnimation, dropdownContainerAnimation] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'mdb-mention', styles: [], animations: [dropdownAnimation, dropdownContainerAnimation], template: "<div [@dropdownContainerAnimation] class=\"mention-dropdown-container\" >\n    <div [@dropdownAnimation] role=\"listbox\" class=\"mention-dropdown\">\n      <ul class=\"mention-items-list\" #dropdownList\n        [ngStyle]=\"{'max-height': optionHeight * visibleItems + 'px'}\">\n        <mention-item\n        *ngFor=\"let item of items\"\n        [mentionValue]=\"mentionValue\"\n        [showImg]=\"showImg\"\n        [queryBy]=\"queryBy\"\n        [optionHeight]=\"optionHeight\"\n        [item]=\"item\"\n        (click)=\"handleOptionClick(item)\"></mention-item>\n        <li\n        *ngIf=\"(items.length === 0 && showNoResultText) || asyncError\"\n        [ngStyle]=\"{'min-height': optionHeight + 'px'}\"\n        class=\"mention-result\">\n        {{ noResultText }}\n      </li>\n      </ul>\n    </div>\n  </div>" }]
        }], ctorParameters: function () { return []; }, propDecorators: { options: [{
                type: ViewChildren,
                args: [MdbMentionItemComponent]
            }], _dropdownList: [{
                type: ViewChild,
                args: ['dropdownList']
            }], optionHeight: [{
                type: Input
            }], optionClick: [{
                type: Output
            }], tabout: [{
                type: Output
            }], handleKeyDown: [{
                type: HostListener,
                args: ['window:keydown', ['$event']]
            }] } });

class MdbMentionDirective {
    constructor(_overlay, _overlayPositionBuilder, _elementRef, _renderer) {
        this._overlay = _overlay;
        this._overlayPositionBuilder = _overlayPositionBuilder;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._overlayRef = null;
        this.placement = 'bottom';
        this.trigger = '@';
        this._outputKey = '';
        this._visibleItems = 5;
        this._disableFilter = false;
        this._showListOnTrigger = true;
        this._asyncError = false;
        this._showImg = false;
        this._noResultText = 'No result found';
        this._items = [];
        this._queryBy = 'username';
        this._showNoResultText = true;
        this.mentionChange = new EventEmitter();
        this.mentionClose = new EventEmitter();
        this.mentionOpen = new EventEmitter();
        this.mentionSelect = new EventEmitter();
        this._mentionRef = null;
        this._open = false;
        this._caretPositionIndex = 0;
        this._isTriggerValid = false;
        this._presentTrigger = '';
        this.mentionValue = '';
        this._destroy$ = new Subject();
    }
    get outputKey() {
        return this._outputKey;
    }
    set outputKey(value) {
        this._outputKey = value;
    }
    get visibleItems() {
        return this._visibleItems;
    }
    set visibleItems(value) {
        this._visibleItems = coerceNumberProperty(value);
        if (this._mentionRef) {
            this._mentionRef.instance.visibleItems = this._visibleItems;
        }
    }
    get disableFilter() {
        return this._disableFilter;
    }
    set disableFilter(value) {
        this._disableFilter = coerceBooleanProperty(value);
    }
    get showListOnTrigger() {
        return this._showListOnTrigger;
    }
    set showListOnTrigger(value) {
        this._showListOnTrigger = coerceBooleanProperty(value);
    }
    get asyncError() {
        return this._asyncError;
    }
    set asyncError(value) {
        this._asyncError = coerceBooleanProperty(value);
        if (this._mentionRef) {
            this._mentionRef.instance.asyncError = this._asyncError;
        }
    }
    get showImg() {
        return this._showImg;
    }
    set showImg(value) {
        this._showImg = coerceBooleanProperty(value);
        if (this._mentionRef) {
            this._mentionRef.instance.showImg = this._showImg;
        }
    }
    get noResultText() {
        return this._noResultText;
    }
    set noResultText(value) {
        this._noResultText = value;
        if (this._mentionRef) {
            this._mentionRef.instance.noResultText = value;
        }
    }
    get items() {
        return this._items;
    }
    set items(value) {
        this._items = value ? value : [];
        if (this._mentionRef) {
            this._mentionRef.instance.items = this._items;
        }
    }
    get queryBy() {
        return this._queryBy;
    }
    set queryBy(value) {
        this._queryBy = value;
        if (this._mentionRef) {
            this._mentionRef.instance.queryBy = this._queryBy;
        }
    }
    get showNoResultText() {
        return this._showNoResultText;
    }
    set showNoResultText(value) {
        this._showNoResultText = coerceBooleanProperty(value);
        if (this._mentionRef) {
            this._mentionRef.instance.showNoResultText = this._showNoResultText;
        }
    }
    ngOnInit() {
        this._renderer.setAttribute(this._elementRef.nativeElement, 'autocomplete', 'off');
        this._bindTriggerEvents();
    }
    _getPosition() {
        let position;
        const positionTop = {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom',
            offsetY: 0,
        };
        const positionBottom = {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top',
            offsetY: 0,
        };
        const positionRight = {
            originX: 'end',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center',
            offsetX: 0,
        };
        const positionLeft = {
            originX: 'start',
            originY: 'center',
            overlayX: 'end',
            overlayY: 'center',
            offsetX: 0,
        };
        switch (this.placement) {
            case 'top':
                position = [positionTop, positionBottom];
                break;
            case 'bottom':
                position = [positionBottom, positionTop];
                break;
            case 'left':
                position = [positionLeft, positionRight];
                break;
            case 'right':
                position = [positionRight, positionLeft];
                break;
            default:
                position = [positionBottom, positionTop];
                break;
        }
        return position;
    }
    _createOverlayConfig() {
        const positionStrategy = this._overlayPositionBuilder
            .flexibleConnectedTo(this._elementRef)
            .withPositions(this._getPosition());
        const overlayConfig = new OverlayConfig({
            width: this._elementRef.nativeElement.offsetWidth,
            hasBackdrop: false,
            scrollStrategy: this._overlay.scrollStrategies.reposition(),
            positionStrategy,
        });
        return overlayConfig;
    }
    _createOverlay() {
        this._overlayRef = this._overlay.create(this._createOverlayConfig());
    }
    _listenToOutSideClick(overlayRef, origin) {
        return fromEvent(document, 'click').pipe(filter((event) => {
            const target = event.target;
            const notOrigin = target !== origin;
            const notOverlay = !!overlayRef && overlayRef.overlayElement.contains(target) === false;
            return notOrigin && notOverlay;
        }), takeUntil(overlayRef.detachments()));
    }
    _handleOptionClick(item) {
        this.mentionSelect.emit(item);
        this._setHostValue(item);
        this.close();
    }
    _setDataForDropdown() {
        let filtereditems;
        if (!this._disableFilter) {
            filtereditems = this._filter(this.mentionValue);
            this._mentionRef.instance.items = filtereditems ? filtereditems : this._items;
        }
        this._mentionRef.instance.mentionValue = this.mentionValue;
    }
    _updateMentionString(caretPositionIndex) {
        const hostValueBeforeCaret = this._elementRef.nativeElement.value.slice(0, caretPositionIndex);
        const triggers = [...this.trigger];
        if (!this._caretPositionIndex) {
            this.mentionValue = '';
            this._isTriggerValid = false;
            return;
        }
        for (let i = hostValueBeforeCaret.length - 1; i >= 0; i--) {
            if (hostValueBeforeCaret.charAt(i) === ' ') {
                this.mentionValue = '';
                this._isTriggerValid = false;
                return;
            }
            if (triggers.some((trigger) => trigger === hostValueBeforeCaret.charAt(i))) {
                if (hostValueBeforeCaret.charAt(i - 1) !== ' ' && i > 1) {
                    return;
                }
                const trigger = hostValueBeforeCaret.charAt(i);
                const hostValueAfterTrigger = this._elementRef.nativeElement.value.slice(i);
                const mentionValues = hostValueAfterTrigger.split(' ')[0];
                const mentionValue = mentionValues.split(trigger)[1] ? mentionValues.split(trigger)[1] : '';
                this.mentionValue = mentionValue;
                this._isTriggerValid = true;
                this._presentTrigger = trigger;
                this.mentionChange.emit({
                    trigger: trigger,
                    searchTerm: this.mentionValue,
                });
                return;
            }
        }
    }
    _toggleDropdown() {
        if (!this._open && this._isTriggerValid) {
            if (!this._showListOnTrigger && this.mentionValue.length < 1) {
                return;
            }
            this.open();
            this._mentionRef.instance.queryBy = this.queryBy;
            this._mentionRef.instance.noResultText = this._noResultText;
            this._mentionRef.instance.showNoResultText = this._showNoResultText;
            this._mentionRef.instance.asyncError = this._asyncError;
            this._mentionRef.instance.showImg = this._showImg;
            this._mentionRef.instance.visibleItems = this._visibleItems;
            return;
        }
        if (!this._isTriggerValid) {
            this.close();
        }
    }
    _handleDropdownByCaret(event) {
        const target = event.target;
        this._caretPositionIndex = target.selectionStart;
        this._updateMentionString(this._caretPositionIndex);
        this._toggleDropdown();
        if (!this._open) {
            return;
        }
        this._setDataForDropdown();
    }
    _bindTriggerEvents() {
        fromEvent(this._elementRef.nativeElement, 'click')
            .pipe(takeUntil(this._destroy$))
            .subscribe((event) => {
            this._handleDropdownByCaret(event);
        });
        fromEvent(this._elementRef.nativeElement, 'keydown')
            .pipe(takeUntil(this._destroy$))
            .subscribe((event) => {
            const { key } = event;
            const isKeyEscape = key === 'Escape';
            const isKeyResponsibleForTabout = key === 'Tab';
            const isKeyResponsibleForDropdownNavigation = ['ArrowUp', 'ArrowDown', 'Escape', 'Home', 'End', 'Enter'].indexOf(key) > -1;
            if (isKeyResponsibleForDropdownNavigation) {
                if (isKeyEscape) {
                    this.close();
                }
                event.preventDefault();
                return;
            }
            if (isKeyResponsibleForTabout) {
                return;
            }
            setTimeout(() => {
                this._handleDropdownByCaret(event);
            }, 0);
        });
    }
    _setHostValue(value) {
        const hostValueBeforeCaret = this._elementRef.nativeElement.value.slice(0, this._caretPositionIndex);
        for (let i = hostValueBeforeCaret.length - 1; i >= 0; i--) {
            if (hostValueBeforeCaret.charAt(i) === ' ') {
                return;
            }
            if (hostValueBeforeCaret.charAt(i) === this._presentTrigger) {
                const hostValueBeforeTrigger = this._elementRef.nativeElement.value.slice(0, i);
                const hostValueAfterTrigger = this._elementRef.nativeElement.value.slice(i);
                const hostNewValueAfterTrigger = hostValueAfterTrigger.split(' ')[1]
                    ? hostValueAfterTrigger.split(' ').splice(1).join(' ')
                    : '';
                this._elementRef.nativeElement.value = hostValueBeforeTrigger.concat(this._presentTrigger, value[this._outputKey ? this._outputKey : this._queryBy], ' ', hostNewValueAfterTrigger);
            }
        }
    }
    _filter(value) {
        const filterValue = value.toLowerCase();
        const filtereditems = this._items.filter((item) => item[this._queryBy].toLowerCase().includes(filterValue));
        return filtereditems;
    }
    open() {
        if (this._open) {
            return;
        }
        if (!this._overlayRef) {
            this._createOverlay();
        }
        if (this._overlayRef.hasAttached()) {
            this._overlayRef.detach();
        }
        const mentionPortal = new ComponentPortal(MdbMentionComponent);
        this._mentionRef = this._overlayRef.attach(mentionPortal);
        this._open = true;
        this._mentionRef.instance.optionClick.subscribe((item) => {
            this._handleOptionClick(item);
        });
        this._mentionRef.instance.tabout.subscribe(() => {
            this.close();
        });
        this._listenToOutSideClick(this._overlayRef, this._elementRef.nativeElement).subscribe(() => this.close());
        this.mentionOpen.emit();
    }
    close() {
        if (this._overlayRef) {
            if (this._overlayRef.hasAttached()) {
                this._overlayRef.detach();
            }
        }
        if (this._open) {
            this._open = false;
        }
        this.mentionClose.emit();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
        if (this._overlayRef) {
            this.close();
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
}
MdbMentionDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionDirective, deps: [{ token: i1$1.Overlay }, { token: i1$1.OverlayPositionBuilder }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
MdbMentionDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.2.7", type: MdbMentionDirective, selector: "input[mdbMention], textarea[mdbMention]", inputs: { placement: "placement", trigger: "trigger", outputKey: "outputKey", visibleItems: "visibleItems", disableFilter: "disableFilter", showListOnTrigger: "showListOnTrigger", asyncError: "asyncError", showImg: "showImg", noResultText: "noResultText", items: "items", queryBy: "queryBy", showNoResultText: "showNoResultText" }, outputs: { mentionChange: "mentionChange", mentionClose: "mentionClose", mentionOpen: "mentionOpen", mentionSelect: "mentionSelect" }, exportAs: ["mdbMention"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'input[mdbMention], textarea[mdbMention]',
                    exportAs: 'mdbMention',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Overlay }, { type: i1$1.OverlayPositionBuilder }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { placement: [{
                type: Input
            }], trigger: [{
                type: Input
            }], outputKey: [{
                type: Input
            }], visibleItems: [{
                type: Input
            }], disableFilter: [{
                type: Input
            }], showListOnTrigger: [{
                type: Input
            }], asyncError: [{
                type: Input
            }], showImg: [{
                type: Input
            }], noResultText: [{
                type: Input
            }], items: [{
                type: Input
            }], queryBy: [{
                type: Input
            }], showNoResultText: [{
                type: Input
            }], mentionChange: [{
                type: Output
            }], mentionClose: [{
                type: Output
            }], mentionOpen: [{
                type: Output
            }], mentionSelect: [{
                type: Output
            }] } });

class MdbMentionModule {
}
MdbMentionModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MdbMentionModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionModule, declarations: [MdbMentionComponent, MdbMentionDirective, MdbMentionItemComponent], imports: [OverlayModule, CommonModule], exports: [MdbMentionComponent, MdbMentionDirective, MdbMentionItemComponent] });
MdbMentionModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionModule, imports: [[OverlayModule, CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: MdbMentionModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MdbMentionComponent, MdbMentionDirective, MdbMentionItemComponent],
                    imports: [OverlayModule, CommonModule],
                    exports: [MdbMentionComponent, MdbMentionDirective, MdbMentionItemComponent],
                }]
        }] });

/*
 * Public API Surface of mdb-angular-mention
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MdbMentionComponent, MdbMentionDirective, MdbMentionItemComponent, MdbMentionModule };
//# sourceMappingURL=mdb-angular-mention.mjs.map
